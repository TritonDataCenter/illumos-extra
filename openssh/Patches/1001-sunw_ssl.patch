From e300e21a87ac6d34f7b1f1f0df9c554fcecd6cfc Mon Sep 17 00:00:00 2001
From: Dan McDonald <danmcd@mnx.io>
Date: Thu, 10 Aug 2023 18:11:52 -0400
Subject: [PATCH 32/32] SmartOS local: use sunw_ssl lib from platform

---
 cipher-chachapoly-libcrypto.c        |  4 +--
 cipher-chachapoly.c                  |  4 +--
 configure.ac                         | 46 ++++++++++++++--------------
 digest-openssl.c                     |  6 ++--
 kex.c                                |  8 ++---
 openbsd-compat/libressl-api-compat.c | 16 +++++-----
 openbsd-compat/openssl-compat.h      | 14 ++++-----
 ssh-pkcs11-client.c                  | 20 ++++++------
 ssh-pkcs11.c                         | 26 ++++++++--------
 9 files changed, 72 insertions(+), 72 deletions(-)

diff --git a/cipher-chachapoly-libcrypto.c b/cipher-chachapoly-libcrypto.c
index e8d20c288..2ebd699c4 100644
--- a/cipher-chachapoly-libcrypto.c
+++ b/cipher-chachapoly-libcrypto.c
@@ -20,7 +20,7 @@
 #include "openbsd-compat/openssl-compat.h"
 #endif
 
-#if defined(HAVE_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20)
+#if defined(HAVE_SUNW_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20)
 
 #include <sys/types.h>
 #include <stdarg.h> /* needed for log.h */
@@ -162,4 +162,4 @@ chachapoly_get_length(struct chachapoly_ctx *ctx,
 	*plenp = PEEK_U32(buf);
 	return 0;
 }
-#endif /* defined(HAVE_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20) */
+#endif /* defined(HAVE_SUNW_EVP_CHACHA20) && !defined(HAVE_BROKEN_CHACHA20) */
diff --git a/cipher-chachapoly.c b/cipher-chachapoly.c
index 4471fe2d2..010de2d38 100644
--- a/cipher-chachapoly.c
+++ b/cipher-chachapoly.c
@@ -20,7 +20,7 @@
 #include "openbsd-compat/openssl-compat.h"
 #endif
 
-#if !defined(HAVE_EVP_CHACHA20) || defined(HAVE_BROKEN_CHACHA20)
+#if !defined(HAVE_SUNW_EVP_CHACHA20) || defined(HAVE_BROKEN_CHACHA20)
 
 #include <sys/types.h>
 #include <stdarg.h> /* needed for log.h */
@@ -135,4 +135,4 @@ chachapoly_get_length(struct chachapoly_ctx *ctx,
 	return 0;
 }
 
-#endif /* !defined(HAVE_EVP_CHACHA20) || defined(HAVE_BROKEN_CHACHA20) */
+#endif /* !defined(HAVE_SUNW_EVP_CHACHA20) || defined(HAVE_BROKEN_CHACHA20) */
diff --git a/configure.ac b/configure.ac
index ce6e0197b..2aae3d2d2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2820,9 +2820,9 @@ AC_ARG_WITH([ssl-engine],
 
 nocrypto_saved_LIBS="$LIBS"
 if test "x$openssl" = "xyes" ; then
-	LIBS="-lcrypto $LIBS"
-	CHANNELLIBS="-lcrypto $CHANNELLIBS"
-	AC_TRY_LINK_FUNC([RAND_add], ,
+	LIBS="-L /usr/lib:${DESTDIR}/usr/lib -lsunw_crypto $LIBS"
+	CHANNELLIBS="-L /usr/lib:${DESTDIR}/usr/lib -lsunw_crypto $CHANNELLIBS"
+	AC_TRY_LINK_FUNC([sunw_RAND_add], ,
 	    [AC_MSG_ERROR([*** working libcrypto not found, check config.log])])
 	AC_CHECK_HEADER([openssl/opensslv.h], ,
 	    [AC_MSG_ERROR([*** OpenSSL headers missing - please install first or check config.log ***])])
@@ -3013,23 +3013,23 @@ if test "x$openssl" = "xyes" ; then
 	)
 
 	AC_CHECK_FUNCS([ \
-		BN_is_prime_ex \
-		DES_crypt \
-		DSA_generate_parameters_ex \
-		EVP_DigestFinal_ex \
-		EVP_DigestInit_ex \
-		EVP_MD_CTX_cleanup \
-		EVP_MD_CTX_copy_ex \
-		EVP_MD_CTX_init \
-		HMAC_CTX_init \
-		RSA_generate_key_ex \
-		RSA_get_default_method \
+		sunw_BN_is_prime_ex \
+		sunw_DES_crypt \
+		sunw_DSA_generate_parameters_ex \
+		sunw_EVP_DigestFinal_ex \
+		sunw_EVP_DigestInit_ex \
+		sunw_EVP_MD_CTX_cleanup \
+		sunw_EVP_MD_CTX_copy_ex \
+		sunw_EVP_MD_CTX_init \
+		sunw_HMAC_CTX_init \
+		sunw_RSA_generate_key_ex \
+		sunw_RSA_get_default_method \
 	])
 
 	# OpenSSL_add_all_algorithms may be a macro.
-	AC_CHECK_FUNC(OpenSSL_add_all_algorithms,
+	AC_CHECK_FUNC(sunw_OpenSSL_add_all_algorithms,
 	    AC_DEFINE(HAVE_OPENSSL_ADD_ALL_ALGORITHMS, 1, [as a function]),
-	    AC_CHECK_DECL(OpenSSL_add_all_algorithms,
+	    AC_CHECK_DECL(sunw_OpenSSL_add_all_algorithms,
 		AC_DEFINE(HAVE_OPENSSL_ADD_ALL_ALGORITHMS, 1, [as a macro]), ,
 		[[#include <openssl/evp.h>]]
 	    )
@@ -3037,11 +3037,11 @@ if test "x$openssl" = "xyes" ; then
 
 	# LibreSSL/OpenSSL API differences
 	AC_CHECK_FUNCS([ \
-		EVP_CIPHER_CTX_iv \
-		EVP_CIPHER_CTX_iv_noconst \
-		EVP_CIPHER_CTX_get_iv \
-		EVP_CIPHER_CTX_get_updated_iv \
-		EVP_CIPHER_CTX_set_iv \
+		sunw_EVP_CIPHER_CTX_iv \
+		sunw_EVP_CIPHER_CTX_iv_noconst \
+		sunw_EVP_CIPHER_CTX_get_iv \
+		sunw_EVP_CIPHER_CTX_get_updated_iv \
+		sunw_EVP_CIPHER_CTX_set_iv \
 	])
 
 	if test "x$openssl_engine" = "xyes" ; then
@@ -3100,7 +3100,7 @@ if test "x$openssl" = "xyes" ; then
 	)
 
 	# Check for various EVP support in OpenSSL
-	AC_CHECK_FUNCS([EVP_sha256 EVP_sha384 EVP_sha512 EVP_chacha20])
+	AC_CHECK_FUNCS([sunw_EVP_sha256 sunw_EVP_sha384 sunw_EVP_sha512 sunw_EVP_chacha20])
 
 	# Check complete ECC support in OpenSSL
 	AC_MSG_CHECKING([whether OpenSSL has NID_X9_62_prime256v1])
@@ -3180,7 +3180,7 @@ if test "x$openssl" = "xyes" ; then
 	if test x$enable_nistp256 = x1 || test x$enable_nistp384 = x1 || \
 	    test x$enable_nistp521 = x1; then
 		AC_DEFINE(OPENSSL_HAS_ECC, [1], [OpenSSL has ECC])
-		AC_CHECK_FUNCS([EC_KEY_METHOD_new])
+		AC_CHECK_FUNCS([sunw_EC_KEY_METHOD_new])
 		openssl_ecc=yes
 	else
 		openssl_ecc=no
diff --git a/digest-openssl.c b/digest-openssl.c
index e073a807b..c0bf66d68 100644
--- a/digest-openssl.c
+++ b/digest-openssl.c
@@ -32,13 +32,13 @@
 #include "digest.h"
 #include "ssherr.h"
 
-#ifndef HAVE_EVP_SHA256
+#ifndef HAVE_SUNW_EVP_SHA256
 # define EVP_sha256 NULL
 #endif
-#ifndef HAVE_EVP_SHA384
+#ifndef HAVE_SUNW_EVP_SHA384
 # define EVP_sha384 NULL
 #endif
-#ifndef HAVE_EVP_SHA512
+#ifndef HAVE_SUNW_EVP_SHA512
 # define EVP_sha512 NULL
 #endif
 
diff --git a/kex.c b/kex.c
index cbb2af596..bb99a68f7 100644
--- a/kex.c
+++ b/kex.c
@@ -95,9 +95,9 @@ static const struct kexalg kexalgs[] = {
 	{ KEX_DH16_SHA512, KEX_DH_GRP16_SHA512, 0, SSH_DIGEST_SHA512 },
 	{ KEX_DH18_SHA512, KEX_DH_GRP18_SHA512, 0, SSH_DIGEST_SHA512 },
 	{ KEX_DHGEX_SHA1, KEX_DH_GEX_SHA1, 0, SSH_DIGEST_SHA1 },
-#ifdef HAVE_EVP_SHA256
+#ifdef HAVE_SUNW_EVP_SHA256
 	{ KEX_DHGEX_SHA256, KEX_DH_GEX_SHA256, 0, SSH_DIGEST_SHA256 },
-#endif /* HAVE_EVP_SHA256 */
+#endif /* HAVE_SUNW_EVP_SHA256 */
 #ifdef OPENSSL_HAS_ECC
 	{ KEX_ECDH_SHA2_NISTP256, KEX_ECDH_SHA2,
 	    NID_X9_62_prime256v1, SSH_DIGEST_SHA256 },
@@ -109,14 +109,14 @@ static const struct kexalg kexalgs[] = {
 # endif /* OPENSSL_HAS_NISTP521 */
 #endif /* OPENSSL_HAS_ECC */
 #endif /* WITH_OPENSSL */
-#if defined(HAVE_EVP_SHA256) || !defined(WITH_OPENSSL)
+#if defined(HAVE_SUNW_EVP_SHA256) || !defined(WITH_OPENSSL)
 	{ KEX_CURVE25519_SHA256, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
 	{ KEX_CURVE25519_SHA256_OLD, KEX_C25519_SHA256, 0, SSH_DIGEST_SHA256 },
 #ifdef USE_SNTRUP761X25519
 	{ KEX_SNTRUP761X25519_SHA512, KEX_KEM_SNTRUP761X25519_SHA512, 0,
 	    SSH_DIGEST_SHA512 },
 #endif
-#endif /* HAVE_EVP_SHA256 || !WITH_OPENSSL */
+#endif /* HAVE_SUNW_EVP_SHA256 || !WITH_OPENSSL */
 	{ NULL, 0, -1, -1},
 };
 
diff --git a/openbsd-compat/libressl-api-compat.c b/openbsd-compat/libressl-api-compat.c
index 59be17397..543e11f85 100644
--- a/openbsd-compat/libressl-api-compat.c
+++ b/openbsd-compat/libressl-api-compat.c
@@ -25,7 +25,7 @@
 
 #include <openssl/evp.h>
 
-#ifndef HAVE_EVP_CIPHER_CTX_GET_IV
+#ifndef HAVE_SUNW_EVP_CIPHER_CTX_GET_IV
 int
 EVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx, unsigned char *iv, size_t len)
 {
@@ -44,17 +44,17 @@ EVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx, unsigned char *iv, size_t len)
 	if (len != 0) {
 		if (iv == NULL)
 			return 0;
-# ifdef HAVE_EVP_CIPHER_CTX_IV
+# ifdef HAVE_SUNW_EVP_CIPHER_CTX_IV
 		memcpy(iv, EVP_CIPHER_CTX_iv(ctx), len);
 # else
 		memcpy(iv, ctx->iv, len);
-# endif /* HAVE_EVP_CIPHER_CTX_IV */
+# endif /* HAVE_SUNW_EVP_CIPHER_CTX_IV */
 	}
 	return 1;
 }
-#endif /* HAVE_EVP_CIPHER_CTX_GET_IV */
+#endif /* HAVE_SUNW_EVP_CIPHER_CTX_GET_IV */
 
-#ifndef HAVE_EVP_CIPHER_CTX_SET_IV
+#ifndef HAVE_SUNW_EVP_CIPHER_CTX_SET_IV
 int
 EVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx, const unsigned char *iv, size_t len)
 {
@@ -73,14 +73,14 @@ EVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx, const unsigned char *iv, size_t len)
 	if (len != 0) {
 		if (iv == NULL)
 			return 0;
-# ifdef HAVE_EVP_CIPHER_CTX_IV_NOCONST
+# ifdef HAVE_SUNW_EVP_CIPHER_CTX_IV_NOCONST
 		memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), iv, len);
 # else
 		memcpy(ctx->iv, iv, len);
-# endif /* HAVE_EVP_CIPHER_CTX_IV_NOCONST */
+# endif /* HAVE_SUNW_EVP_CIPHER_CTX_IV_NOCONST */
 	}
 	return 1;
 }
-#endif /* HAVE_EVP_CIPHER_CTX_SET_IV */
+#endif /* HAVE_SUNW_EVP_CIPHER_CTX_SET_IV */
 
 #endif /* WITH_OPENSSL */
diff --git a/openbsd-compat/openssl-compat.h b/openbsd-compat/openssl-compat.h
index f6796b3ba..9a333d646 100644
--- a/openbsd-compat/openssl-compat.h
+++ b/openbsd-compat/openssl-compat.h
@@ -64,19 +64,19 @@ void ssh_libcrypto_init(void);
 # define BN_set_flags(a, b)
 #endif
 
-#ifndef HAVE_EVP_CIPHER_CTX_GET_IV
-# ifdef HAVE_EVP_CIPHER_CTX_GET_UPDATED_IV
+#ifndef HAVE_SUNW_EVP_CIPHER_CTX_GET_IV
+# ifdef HAVE_SUNW_EVP_CIPHER_CTX_GET_UPDATED_IV
 #  define EVP_CIPHER_CTX_get_iv EVP_CIPHER_CTX_get_updated_iv
-# else /* HAVE_EVP_CIPHER_CTX_GET_UPDATED_IV */
+# else /* HAVE_SUNW_EVP_CIPHER_CTX_GET_UPDATED_IV */
 int EVP_CIPHER_CTX_get_iv(const EVP_CIPHER_CTX *ctx,
     unsigned char *iv, size_t len);
-# endif /* HAVE_EVP_CIPHER_CTX_GET_UPDATED_IV */
-#endif /* HAVE_EVP_CIPHER_CTX_GET_IV */
+# endif /* HAVE_SUNW_EVP_CIPHER_CTX_GET_UPDATED_IV */
+#endif /* HAVE_SUNW_EVP_CIPHER_CTX_GET_IV */
 
-#ifndef HAVE_EVP_CIPHER_CTX_SET_IV
+#ifndef HAVE_SUNW_EVP_CIPHER_CTX_SET_IV
 int EVP_CIPHER_CTX_set_iv(EVP_CIPHER_CTX *ctx,
     const unsigned char *iv, size_t len);
-#endif /* HAVE_EVP_CIPHER_CTX_SET_IV */
+#endif /* HAVE_SUNW_EVP_CIPHER_CTX_SET_IV */
 
 #endif /* WITH_OPENSSL */
 #endif /* _OPENSSL_COMPAT_H */
diff --git a/ssh-pkcs11-client.c b/ssh-pkcs11-client.c
index 82e86a518..81db1a622 100644
--- a/ssh-pkcs11-client.c
+++ b/ssh-pkcs11-client.c
@@ -48,7 +48,7 @@
 
 #include "openbsd-compat/openssl-compat.h"
 
-#if !defined(OPENSSL_HAS_ECC) || !defined(HAVE_EC_KEY_METHOD_NEW)
+#if !defined(OPENSSL_HAS_ECC) || !defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 #define EC_KEY_METHOD void
 #define EC_KEY void
 #endif
@@ -103,7 +103,7 @@ helper_by_rsa(const RSA *rsa)
 
 }
 
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 static struct helper *
 helper_by_ec(const EC_KEY *ec)
 {
@@ -119,7 +119,7 @@ helper_by_ec(const EC_KEY *ec)
 	return NULL;
 
 }
-#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW) */
+#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW) */
 
 static void
 helper_free(struct helper *helper)
@@ -148,7 +148,7 @@ helper_free(struct helper *helper)
 		nhelpers--;
 	}
 	free(helper->path);
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 	EC_KEY_METHOD_free(helper->ec_meth);
 #endif
 	RSA_meth_free(helper->rsa_meth);
@@ -322,7 +322,7 @@ rsa_finish(RSA *rsa)
 	return 1;
 }
 
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 static ECDSA_SIG *
 ecdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,
     const BIGNUM *rp, EC_KEY *ec)
@@ -402,7 +402,7 @@ ecdsa_do_finish(EC_KEY *ec)
 	if (helper->nrsa == 0 && helper->nec == 0)
 		helper_terminate(helper);
 }
-#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW) */
+#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW) */
 
 /* redirect private key crypto operations to the ssh-pkcs11-helper */
 static void
@@ -413,7 +413,7 @@ wrap_key(struct helper *helper, struct sshkey *k)
 		RSA_set_method(k->rsa, helper->rsa_meth);
 		if (helper->nrsa++ >= INT_MAX)
 			fatal_f("RSA refcount error");
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 	} else if (k->type == KEY_ECDSA) {
 		EC_KEY_set_method(k->ecdsa, helper->ec_meth);
 		if (helper->nec++ >= INT_MAX)
@@ -485,7 +485,7 @@ pkcs11_start_helper_methods(struct helper *helper)
 {
 	RSA_METHOD *rsa_meth;
 	EC_KEY_METHOD *ec_meth = NULL;
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 	int (*ec_init)(EC_KEY *key);
 	int (*ec_copy)(EC_KEY *dest, const EC_KEY *src);
 	int (*ec_set_group)(EC_KEY *key, const EC_GROUP *grp);
@@ -502,7 +502,7 @@ pkcs11_start_helper_methods(struct helper *helper)
 	    &ec_copy, &ec_set_group, &ec_set_private, &ec_set_public);
 	EC_KEY_METHOD_set_init(ec_meth, ec_init, ecdsa_do_finish,
 	    ec_copy, ec_set_group, ec_set_private, ec_set_public);
-#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW) */
+#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW) */
 
 	if ((rsa_meth = RSA_meth_dup(RSA_get_default_method())) == NULL)
 		fatal_f("RSA_meth_dup failed");
@@ -543,7 +543,7 @@ pkcs11_start_helper(const char *path)
 		close(pair[0]);
 		close(pair[1]);
 		RSA_meth_free(helper->rsa_meth);
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 		EC_KEY_METHOD_free(helper->ec_meth);
 #endif
 		free(helper);
diff --git a/ssh-pkcs11.c b/ssh-pkcs11.c
index 35e98be72..213ec1754 100644
--- a/ssh-pkcs11.c
+++ b/ssh-pkcs11.c
@@ -79,7 +79,7 @@ struct pkcs11_key {
 
 int pkcs11_interactive = 0;
 
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 static void
 ossl_error(const char *msg)
 {
@@ -89,7 +89,7 @@ ossl_error(const char *msg)
 	while ((e = ERR_get_error()) != 0)
 		error_f("libcrypto error: %s", ERR_error_string(e, NULL));
 }
-#endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
+#endif /* OPENSSL_HAS_ECC && HAVE_SUNW_EC_KEY_METHOD_NEW */
 
 int
 pkcs11_init(int interactive)
@@ -190,10 +190,10 @@ pkcs11_del_provider(char *provider_id)
 
 static RSA_METHOD *rsa_method;
 static int rsa_idx = 0;
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 static EC_KEY_METHOD *ec_key_method;
 static int ec_key_idx = 0;
-#endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
+#endif /* OPENSSL_HAS_ECC && HAVE_SUNW_EC_KEY_METHOD_NEW */
 
 /* release a wrapped object */
 static void
@@ -507,7 +507,7 @@ pkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
 	return (0);
 }
 
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 /* openssl callback doing the actual signing operation */
 static ECDSA_SIG *
 ecdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,
@@ -620,7 +620,7 @@ pkcs11_ecdsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,
 
 	return (0);
 }
-#endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
+#endif /* OPENSSL_HAS_ECC && HAVE_SUNW_EC_KEY_METHOD_NEW */
 
 /* remove trailing spaces */
 static char *
@@ -698,7 +698,7 @@ pkcs11_key_included(struct sshkey ***keysp, int *nkeys, struct sshkey *key)
 	return (0);
 }
 
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 static struct sshkey *
 pkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
     CK_OBJECT_HANDLE *obj)
@@ -821,7 +821,7 @@ fail:
 
 	return (key);
 }
-#endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
+#endif /* OPENSSL_HAS_ECC && HAVE_SUNW_EC_KEY_METHOD_NEW */
 
 static struct sshkey *
 pkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
@@ -929,7 +929,7 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 #endif
 	struct sshkey		*key = NULL;
 	int			 i;
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 	int			 nid;
 #endif
 	const u_char		*cp;
@@ -1018,7 +1018,7 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 		key->type = KEY_RSA;
 		key->flags |= SSHKEY_FLAG_EXT;
 		rsa = NULL;	/* now owned by key */
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 	} else if (EVP_PKEY_base_id(evp) == EVP_PKEY_EC) {
 		if (EVP_PKEY_get0_EC_KEY(evp) == NULL) {
 			error("invalid x509; no ec key");
@@ -1049,7 +1049,7 @@ pkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,
 		key->type = KEY_ECDSA;
 		key->flags |= SSHKEY_FLAG_EXT;
 		ec = NULL;	/* now owned by key */
-#endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
+#endif /* OPENSSL_HAS_ECC && HAVE_SUNW_EC_KEY_METHOD_NEW */
 	} else {
 		error("unknown certificate key type");
 		goto out;
@@ -1273,11 +1273,11 @@ pkcs11_fetch_keys(struct pkcs11_provider *p, CK_ULONG slotidx,
 		case CKK_RSA:
 			key = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);
 			break;
-#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_SUNW_EC_KEY_METHOD_NEW)
 		case CKK_ECDSA:
 			key = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);
 			break;
-#endif /* OPENSSL_HAS_ECC && HAVE_EC_KEY_METHOD_NEW */
+#endif /* OPENSSL_HAS_ECC && HAVE_SUNW_EC_KEY_METHOD_NEW */
 		default:
 			/* XXX print key type? */
 			key = NULL;
-- 
2.34.1

